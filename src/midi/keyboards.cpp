#include <bits/stdint-intn.h>
#include <cstdlib>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "midi/keyboards.hpp"
#include <ncurses.h>

Keyboard::Keyboard() :/*{{{*/
	device( NULL ),
	port( "hw:1,0,0" ),
	MIDI( Switch::OFF )
{
	*name = '\0';
	activeMode = false;
	passiveMode = false;
	part = 1;
}/*}}}*/

void Keyboard::connect() noexcept/*{{{*/
{
	if ( snd_rawmidi_open( NULL, &device, port, SND_RAWMIDI_SYNC ) ) {
		endwin();
		std::cerr << "No se pudo abir " << port << " en Keyboad::connect()" << std::endl;
		exit( EXIT_FAILURE );
	}
	MIDI = Switch::ON;
}/*}}}*/

void Keyboard::disconnect() noexcept/*{{{*/
{
	snd_rawmidi_close( device );
	device = NULL;
	MIDI = Switch::OFF;
}/*}}}*/

void Keyboard::toggle_MIDI_state() noexcept/*{{{*/
{
	MIDI == Switch::OFF ? connect() : disconnect();
}/*}}}*/

void Keyboard::set_buffer( const Performance &_Performance ) noexcept/*{{{*/
{
	performance_buffer = _Performance;
}/*}}}*/

auto Keyboard::get_buffer() noexcept -> const Performance& {/*{{{*/
	return performance_buffer;
}/*}}}*/

void Keyboard::reset_variation() noexcept/*{{{*/
{
	variacion = performance_buffer.initial_scene;
}/*}}}*/

void Keyboard::prev_variation() noexcept/*{{{*/
{
	if ( variacion > 0 )
		--variacion;
}/*}}}*/

void Keyboard::next_variation() noexcept/*{{{*/
{
	if ( variacion < performance_buffer.n_scenes - 1 )
		++variacion;
}/*}}}*/

void Keyboard::set_variation( const int16_t _Variacion ) noexcept/*{{{*/
{
	if ( _Variacion < performance_buffer.n_scenes )
		variacion = _Variacion;
}/*}}}*/

void Keyboard::dump_variation() noexcept/*{{{*/
{
	// sleep
	/*
	 * static struct timespec keyboardTimer;
		keyboardTimer.tv_sec 	= 0;
		keyboardTimer.tv_nsec	= 200000000;
	*/

	// apagar sonidos
	//	unsigned char allSoundsOff[3] = {0xB0, 0x7B, 0x7F};

	// cambio de página
	//	unsigned char pageSysEx[2][7] =    {{0xF0, 0x42, 0x30, 0x7A, 0x4E, 0x00, 0xF7},
	//										{0xF0, 0x42, 0x30, 0x7A, 0x4E, 0x01, 0xF7}};
				
	///////////////////- Track: col 7 - control: col 9 - Value: col 11 /////////////////////////

	// Status (todos en OFF)
		unsigned char x50_on_off[8][13] = 
		{	{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x01, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x03, 0x00, 0x03, 0x00, 0x01, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x04, 0x00, 0x03, 0x00, 0x01, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x05, 0x00, 0x03, 0x00, 0x01, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x06, 0x00, 0x03, 0x00, 0x01, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x07, 0x00, 0x03, 0x00, 0x01, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x08, 0x00, 0x03, 0x00, 0x01, 0xF7}	};

	// Volúmen [X][11] es el volúmen
		[[ maybe_unused ]]unsigned char x50_volume[8][13] =
		{	{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x06, 0x00, 0x02, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x07, 0x00, 0x02, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0xF7}	};

	// Lower Key (C-1)
		unsigned char x50_lower_key[8][13] = 
		{	{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x01, 0x00, 0x22, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x02, 0x00, 0x22, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x03, 0x00, 0x22, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x04, 0x00, 0x22, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x05, 0x00, 0x22, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x06, 0x00, 0x22, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x07, 0x00, 0x22, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x08, 0x00, 0x22, 0x00, 0x00, 0xF7}	};

	// Upper Key (C-1)
		unsigned char x50_upper_key[8][13] = 
		{	{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x01, 0x00, 0x1F, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x02, 0x00, 0x1F, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x03, 0x00, 0x1F, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x04, 0x00, 0x1F, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x05, 0x00, 0x1F, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x06, 0x00, 0x1F, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x07, 0x00, 0x1F, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x08, 0x00, 0x1F, 0x00, 0x00, 0xF7}	};

	// Transposition (0)
		unsigned char x50_transposition[8][13] = 
		{	{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x01, 0x00, 0x0A, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x02, 0x00, 0x0A, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x03, 0x00, 0x0A, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x04, 0x00, 0x0A, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x05, 0x00, 0x0A, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x06, 0x00, 0x0A, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x07, 0x00, 0x0A, 0x00, 0x00, 0xF7},
			{0xF0, 0x42, 0x30, 0x7A, 0x41, 0x01, 0x00, 0x08, 0x00, 0x0A, 0x00, 0x00, 0xF7}	};

	// Ajuste
	for ( int16_t i = 0; i < 8; ++i ) {
		// STATE
		if ( performance_buffer.scenes[variacion].tracks[i].state == ON )
			x50_on_off[i][11] = 0x00; // -> ON

		// volumen
		x50_volume[i][11] = performance_buffer.scenes[variacion].tracks[i].volume;

		// zone
		x50_lower_key[i][11] = performance_buffer.scenes[variacion].tracks[i].lower_key;
		x50_upper_key[i][11] = performance_buffer.scenes[variacion].tracks[i].upper_key;

		// transposition =	columna 11 hacemos + porque es número negativo, de este modo
		// 					obtenemos una RESTA
		if ( performance_buffer.scenes[variacion].tracks[i].transposition < 0 ) {
			x50_transposition[i][10] = 0x7F;
			x50_transposition[i][11] = 0x80 + performance_buffer.scenes[variacion].tracks[i].transposition;
		}
		else
			x50_transposition[i][11] = performance_buffer.scenes[variacion].tracks[i].transposition;
	}

	for ( int16_t channel = 0; channel < 8; ++channel ) {
		snd_rawmidi_write( device, x50_on_off[channel], 13 );
		snd_rawmidi_write( device, x50_volume[channel], 13 );
		snd_rawmidi_write( device, x50_lower_key[channel], 13);
		snd_rawmidi_write( device, x50_upper_key[channel], 13);
		snd_rawmidi_write( device, x50_transposition[channel], 13);
	}
}/*}}}*/

void Keyboard::dump_variation( const Performance &_Performance, const int16_t &_Variacion ) noexcept/*{{{*/
{
	set_buffer( _Performance );
	variacion = _Variacion;
	dump_variation();
}/*}}}*/

void Keyboard::set_name(const char *id)/*{{{*/
{
	sprintf(name, "%s", id);
}/*}}}*/

void Keyboard::select_page( const enum Page &_Pagina ) noexcept/*{{{*/
{
	// sleep
	static struct timespec keyboardTimer;
		keyboardTimer.tv_sec 	= 0;
		keyboardTimer.tv_nsec	= 200000000;

	// cambio de página
	unsigned char pageSysEx[2][7] =    {{0xF0, 0x42, 0x30, 0x7A, 0x4E, 0x00, 0xF7},
										{0xF0, 0x42, 0x30, 0x7A, 0x4E, 0x01, 0xF7}};

	snd_rawmidi_write( device, pageSysEx[ _Pagina ], 7 );
	nanosleep( &keyboardTimer, NULL );

	set_variation( performance_buffer.initial_scene );
}/*}}}*/

void Keyboard::set_modality(short toMode)/*{{{*/
{
	snd_rawmidi_t *device = NULL;
	unsigned char sysex[7] = {0xF0, 0x42, 0x00, 0x7A, 0x4E, 0x00, 0xF7}; //Ch = sysex[2] (LSB)

	if (toMode == MULTI)
		sysex[5] = 0x04;

	
	snd_rawmidi_write(device, sysex, 7);
}/*}}}*/

void Keyboard::set_program( const Performance &_Performance ) noexcept/*{{{*/
{
	set_buffer( _Performance ); // We pass to the buffer

	// sleep
	static struct timespec keyboardTimer;
		keyboardTimer.tv_sec 	= 0;
		keyboardTimer.tv_nsec	= 200000000;

	// cambio de página
	unsigned char pageSysEx[2][7] =    {{0xF0, 0x42, 0x30, 0x7A, 0x4E, 0x00, 0xF7},
										{0xF0, 0x42, 0x30, 0x7A, 0x4E, 0x01, 0xF7}};

	// Midi Ch = msb[0], lsb[0], pc[0] igual, solo el ultimo digito
	unsigned char msb[3] = {0xB0, 0x00, 0x3F}, lsb[3] = {0xB0, 0x20, 0x00}, pc[2] = {0xC0, 0x00};

	// ajuste
	lsb[2] = performance_buffer.patch.bnk - 65; /*LSB*/
	pc[1] = performance_buffer.patch.num; /*PC*/

	snd_rawmidi_write( device, pageSysEx[COMBI], 7 );
	nanosleep( &keyboardTimer, NULL );
		snd_rawmidi_write(device, msb, 3);
		snd_rawmidi_write(device, lsb, 3);
		snd_rawmidi_write(device, pc, 2);
	snd_rawmidi_write( device, pageSysEx[TIMBRE], 7 );
	nanosleep( &keyboardTimer, NULL );

	set_variation( performance_buffer.initial_scene );
	dump_variation();
}/*}}}*/

auto Keyboard::load_buffer() noexcept -> void {/*{{{*/
	set_program( performance_buffer );
}/*}}}*/

void Keyboard::set_song(const char song)/*{{{*/
{
	snd_rawmidi_t *device = NULL;
	unsigned char songSelect[2] = {0xF3, 0x00};

	
	songSelect[1] = song; /*SongSelect */
		snd_rawmidi_write(device, songSelect, 2);	
}/*}}}*/

enum Switch Keyboard::get_MIDI_state() noexcept/*{{{*/
{
	return MIDI;
}/*}}}*/

bool Keyboard::is_connected() noexcept/*{{{*/
{
	return MIDI == Switch::ON ? true : false;
}/*}}}*/
